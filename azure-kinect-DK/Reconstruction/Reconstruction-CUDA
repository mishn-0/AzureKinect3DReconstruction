import open3d.core as o3c
print(o3c.Device("CUDA:0"))  # should print something like: CUDA:0

import numpy as np
import open3d as o3d
import open3d.core as o3c
from pyk4a import PyK4A, Config, ColorResolution, DepthMode
import cv2
import time

device = o3c.Device("CUDA:0")

class CUDAKinectReconstructor:
    def __init__(self):
        self.k4a = PyK4A(Config(
            color_resolution=ColorResolution.RES_720P,
            depth_mode=DepthMode.NFOV_UNBINNED,
            synchronized_images_only=True,
        ))
        self.k4a.start()

        self.intrinsics = o3d.camera.PinholeCameraIntrinsic(
            width=1280, height=720,
            fx=605.286, fy=605.699,
            cx=637.134, cy=366.758
        )

        self.intrinsic_t = o3d.core.Tensor([
            [self.intrinsics.get_focal_length()[0], 0, self.intrinsics.get_principal_point()[0]],
            [0, self.intrinsics.get_focal_length()[1], self.intrinsics.get_principal_point()[1]],
            [0, 0, 1]
        ], dtype=o3c.Dtype.Float32, device=device)

        self.flip_transform = np.array([
            [1,  0,  0, 0],
            [0, -1,  0, 0],
            [0,  0, -1, 0],
            [0,  0,  0, 1]
        ])

        self.global_model = o3d.t.geometry.PointCloud(device)
        self.frame_count = 0

    def capture_rgbd(self):
        capture = self.k4a.get_capture()
        if capture.color is None or capture.transformed_depth is None:
            return None

        color = cv2.cvtColor(cv2.flip(capture.color, -1), cv2.COLOR_BGR2RGB)
        depth = cv2.flip(capture.transformed_depth, -1)

        color_tensor = o3c.Tensor(color, dtype=o3c.uint8, device=device).permute(2, 0, 1)
        depth_tensor = o3c.Tensor(depth, dtype=o3c.uint16, device=device)

        rgbd = o3d.t.geometry.RGBDImage.create_from_color_and_depth(
            o3d.t.geometry.Image(color_tensor),
            o3d.t.geometry.Image(depth_tensor),
            depth_scale=1000.0,
            depth_trunc=3.0,
            convert_rgb_to_intensity=False
        )
        return rgbd

    def run(self):
        print("[INFO] Starting CUDA-enabled reconstruction... Press Ctrl+C to stop.")
        try:
            while True:
                rgbd = self.capture_rgbd()
                if rgbd is None:
                    continue

                pcd = o3d.t.geometry.PointCloud.create_from_rgbd_image(
                    rgbd,
                    self.intrinsic_t,
                    depth_scale=1000.0,
                    depth_max=3.0
                ).to(device)

                pcd.transform(self.flip_transform)

                if self.frame_count == 0:
                    self.global_model = pcd
                else:
                    self.global_model = self.global_model.append(pcd)

                self.frame_count += 1
                print(f"[Frame] {self.frame_count}, Points: {self.global_model.point.positions.shape[0]}")

        except KeyboardInterrupt:
            print("[INFO] Stopping reconstruction...")
            self.save_model()

    def save_model(self):
        self.global_model.estimate_normals()
        cpu_model = self.global_model.to_legacy().to_legacy()
        timestamp = time.strftime("%Y%m%d-%H%M%S")
        filename = f"reconstruction_output/reconstruction_cuda_{timestamp}.ply"
        o3d.io.write_point_cloud(filename, cpu_model)
        print(f"[INFO] Saved CUDA point cloud to: {filename}")

if __name__ == "__main__":
    CUDAKinectReconstructor().run()
